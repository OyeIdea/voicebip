package webrtc_gateway

import (
	"encoding/json"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/gorilla/websocket"
	"github.com/pion/webrtc/v3"
)

func TestSignalMessageJSON(t *testing.T) {
	offerPayload := `{"sdp": "v=0...", "type": "offer"}`
	msg := SignalMessage{
		Type:    "offer",
		Payload: offerPayload,
	}

	jsonData, err := json.Marshal(msg)
	if err != nil {
		t.Fatalf("Failed to marshal SignalMessage: %v", err)
	}

	var unmarshalledMsg SignalMessage
	err = json.Unmarshal(jsonData, &unmarshalledMsg)
	if err != nil {
		t.Fatalf("Failed to unmarshal SignalMessage: %v", err)
	}

	if unmarshalledMsg.Type != msg.Type {
		t.Errorf("Expected Type %s, got %s", msg.Type, unmarshalledMsg.Type)
	}
	if unmarshalledMsg.Payload != msg.Payload {
		t.Errorf("Expected Payload %s, got %s", msg.Payload, unmarshalledMsg.Payload)
	}
}

// This test simulates a basic WebSocket client sending an offer and receiving an answer.
// It doesn't test the full WebRTC ICE/media flow, but checks the signaling.
func TestWebSocketSignaling_OfferAnswer(t *testing.T) {
	cfg := LoadConfig() // Use default config
	var smClient SessionManagerClient = &DummyWebRTCSessionManagerClient{}

	peerConnectionConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{{URLs: cfg.StunServers}},
	}

	// Create a test HTTP server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		HandleWebSocketConnections(w, r, peerConnectionConfig, smClient)
	}))
	defer server.Close()

	// Convert http:// to ws://
	wsURL := "ws" + strings.TrimPrefix(server.URL, "http")

	// Connect to the server
	ws, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
	if err != nil {
		t.Fatalf("Failed to connect to WebSocket server: %v", err)
	}
	defer ws.Close()

	log.Println("Test client connected to WebSocket server.")

	// --- Simulate Client Sending an Offer ---
	// In a real client, this offer would be generated by its local PeerConnection.
	// For this test, we send a simplified, conceptual offer.
	// A real SDP offer is much more complex.
	mockOfferSDP := webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  "v=0\r\no=- 12345 67890 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\nm=audio 9 RTP/AVP 0\r\na=rtpmap:0 PCMU/8000\r\n", // Simplified SDP
	}
	offerPayloadBytes, err := json.Marshal(mockOfferSDP)
	if err != nil {
		t.Fatalf("Failed to marshal mock offer: %v", err)
	}

	offerMsg := SignalMessage{Type: "offer", Payload: string(offerPayloadBytes)}
	if err := ws.WriteJSON(offerMsg); err != nil {
		t.Fatalf("Failed to send offer message: %v", err)
	}
	log.Println("Test client sent offer.")

	// --- Client Receives Answer (and potentially candidates) ---
	// We expect an "answer" message. We might also get "candidate" messages.
	// For this test, we'll primarily look for the answer.
	var answerReceived bool
	var wg sync.WaitGroup
	wg.Add(1) // To wait for the answer

	go func() {
		defer wg.Done()
		for {
			var receivedMsg SignalMessage
			// Set a read deadline to prevent test from hanging indefinitely
			ws.SetReadDeadline(time.Now().Add(5 * time.Second))
			err := ws.ReadJSON(&receivedMsg)
			if err != nil {
				// Check if it's a timeout or actual error
				if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
					log.Println("Test client ReadJSON timeout (expected if no more messages).")
					if !answerReceived {
						// If we timed out before getting an answer, it's a problem.
						// This might happen if ICE gathering takes too long or fails in the test environment.
						// For a unit test, this might be acceptable if we're not testing full ICE.
						log.Println("Test client did not receive an answer within the timeout.")
					}
				} else {
					log.Printf("Test client error reading message: %v", err)
				}
				return // Exit goroutine on error or timeout
			}

			log.Printf("Test client received message: Type=%s", receivedMsg.Type)

			if receivedMsg.Type == "answer" {
				answerReceived = true
				var answerSDP webrtc.SessionDescription
				if err := json.Unmarshal([]byte(receivedMsg.Payload), &answerSDP); err != nil {
					t.Errorf("Failed to unmarshal answer SDP payload: %v. Payload: %s", err, receivedMsg.Payload)
				} else {
					if answerSDP.Type != webrtc.SDPTypeAnswer {
						t.Errorf("Expected answer SDP type 'answer', got '%s'", answerSDP.Type)
					}
					if len(answerSDP.SDP) == 0 {
						t.Errorf("Received answer SDP is empty")
					}
					log.Println("Test client successfully received and parsed answer.")
				}
				// Normally, we might break here if only testing offer/answer.
				// However, candidates might also arrive.
				// For this test, once answer is seen, we are good.
				// The timeout will handle exiting the loop.
			} else if receivedMsg.Type == "candidate" {
				log.Println("Test client received an ICE candidate.")
				// Further validation of candidate could be done here.
			} else if receivedMsg.Type == "error" {
				t.Errorf("Test client received error from server: %s", receivedMsg.Payload)
				return 
			}
		}
	}()

	// Wait for the goroutine to finish (either by receiving messages or timeout)
	wg.Wait()

	if !answerReceived {
		t.Errorf("Test client did not receive an answer message from the server.")
	}

	log.Println("TestWebSocketSignaling_OfferAnswer completed.")
}

// TestStartWebRTCGateway_Conceptual is a placeholder for testing server startup.
// Actual testing of a running HTTP server is more of an integration test.
func TestStartWebRTCGateway_Conceptual(t *testing.T) {
	// This test is mostly conceptual.
	// To truly test StartWebRTCGateway, you'd run it in a goroutine,
	// then make HTTP/WebSocket requests to its port, and then shut it down.
	// This is complex for a unit test.

	// We can verify that LoadConfig works as expected.
	cfg := LoadConfig()
	if cfg.SignalPort == 0 {
		t.Error("LoadConfig returned a zero SignalPort, which is unlikely to be correct.")
	}
	if cfg.ListenAddress == "" {
		t.Error("LoadConfig returned an empty ListenAddress.")
	}
	if len(cfg.StunServers) == 0 {
		t.Log("Warning: LoadConfig returned no STUN servers. This might be intended for some environments but often required.")
	}

	t.Log("TestStartWebRTCGateway_Conceptual: Verified LoadConfig. Full server start test is more of an integration test.")
}
